#!/usr/bin/env bash
# ai-sandbox — Secure wrapper for AI coding tools
#
# Threat model: accidental exfiltration — agent reads a sensitive file
# and includes it in context without the user noticing.
#
# Protection layers:
#   1. Filesystem blacklist (global static + project dynamic)
#   2. Environment clearenv + explicit whitelist
#   3. Docker socket mediation via docker-socket-proxy (TODO)
#
# Strategies:
#   Linux  → firejail (--noprofile + --blacklist per path)
#   macOS  → docker run with selective volume mounts (stub, see TODO)
#
# Usage:
#   ai-sandbox <project-dir> <command> [args...]
#   ai-sandbox init [project-dir]      # generate .ai-sandbox config
#
# Examples:
#   ai-sandbox ~/myproject claude
#   ai-sandbox init ~/myproject
#   ai-sandbox . codex --model gpt-4o
#
# Environment overrides:
#   AI_SANDBOX_IMAGE    Docker image for macOS strategy (default: ai-sandbox)

set -euo pipefail

# ── Global blacklist (static) ──────────────────────────────────────────────
# Always blocked regardless of project. Cannot be overridden by .ai-sandbox.
#
# Credential directories (~/.ssh, ~/.aws, ~/.docker, …) are intentionally NOT
# listed here: the agent needs to operate with the user's identity (git push,
# gh CLI, AWS CLI, docker pull). Blocking them prevents the agent from doing
# useful work without meaningfully reducing accidental-exfiltration risk for
# trusted tools.
#
# ~/.config is also excluded: most entries are tool configs with no secrets
# (gh, codex, nvim, …). Add targeted entries if needed, e.g.
# "$HOME/.config/gcloud" or "$HOME/.config/github-copilot".
GLOBAL_BLACKLIST=()

# ── Global project-level blacklist (patterns) ─────────────────────────────
# Relative patterns blocked in every project, even if the file is tracked.
# Matched against `git ls-files` output (committed files only).
# Can be overridden by AI_SANDBOX_ALLOW_PATHS in .ai-sandbox.
GLOBAL_PROJECT_BLACKLIST=(
    ".envrc"      # direnv — often tracked but may contain secrets
    "**/.envrc"
    ".env"        # fallback env file — frequently contains secrets
    "**/.env"
)

# ── Global tool directory allowlist ────────────────────────────────────────
# Project-level directories that AI tools need to function correctly, even
# when gitignored. These override the dynamic blacklist (gitignored files).
# Paths are relative to the project git root.
GLOBAL_TOOL_ALLOWLIST=(
    ".claude"    # Claude Code — project settings, AGENT.md
    ".codex"     # OpenAI Codex CLI — project config
    ".aider"     # Aider — conversation history, config
    ".continue"  # Continue.dev — context, config
)

# ── Project config defaults ────────────────────────────────────────────────
# Overridden by .ai-sandbox in the project git root.
AI_SANDBOX_ALLOW_PATHS=()
AI_SANDBOX_BLOCK_PATHS=()

# ── Helpers ────────────────────────────────────────────────────────────────

die()  { echo "ai-sandbox: ERROR: $*" >&2; exit 1; }
log()  { echo "ai-sandbox: $*" >&2; }

detect_os() {
    case "$(uname -s)" in
        Linux)  echo linux ;;
        Darwin) echo macos ;;
        *)      die "Unsupported OS: $(uname -s)" ;;
    esac
}

require_cmd() {
    command -v "$1" >/dev/null 2>&1 \
        || die "Required command not found: '$1'. Install it and retry."
}

# ── Project config (.ai-sandbox) ──────────────────────────────────────────

# Loads .ai-sandbox from the git root of project_dir, if present.
# Sets AI_SANDBOX_{ALLOW,BLOCK}_PATHS globals.
load_project_config() {
    local project_dir="$1"

    git -C "$project_dir" rev-parse --git-dir >/dev/null 2>&1 || return 0

    local git_root config
    git_root="$(git -C "$project_dir" rev-parse --show-toplevel)"
    config="$git_root/.ai-sandbox"

    [[ -f "$config" ]] || return 0

    log "Loading project config: $config"
    # shellcheck source=/dev/null
    source "$config"
}

# Returns 0 if the absolute path is allowed by either:
#   1. GLOBAL_TOOL_ALLOWLIST — hardcoded AI tool dirs (always allowed)
#   2. AI_SANDBOX_ALLOW_PATHS — project-level config (.ai-sandbox)
# Patterns are relative to git_root; glob syntax is supported.
# A directory pattern (e.g. target/) also allows everything beneath it.
#
# project_dir (optional, defaults to git_root): also checked as base for
# GLOBAL_TOOL_ALLOWLIST, so tool dirs in a subdirectory project are rescued.
is_path_allowed() {
    local path="$1" git_root="$2" project_dir="${3:-$2}"
    local allow abs_allow base

    shopt -s globstar 2>/dev/null || true

    # Global tool allowlist — checked against both git_root and project_dir
    # so that tool dirs in a monorepo subdirectory are correctly rescued.
    for allow in "${GLOBAL_TOOL_ALLOWLIST[@]}"; do
        for base in "$git_root" "$project_dir"; do
            [[ "$allow" == /* ]] \
                && abs_allow="${allow%/}" \
                || abs_allow="$base/${allow%/}"
            [[ "$path" == $abs_allow || "$path" == "$abs_allow/"* ]] && return 0
        done
    done

    # Project-level allowlist from .ai-sandbox
    for allow in "${AI_SANDBOX_ALLOW_PATHS[@]+${AI_SANDBOX_ALLOW_PATHS[@]}}"; do
        [[ "$allow" == /* ]] \
            && abs_allow="${allow%/}" \
            || abs_allow="$git_root/${allow%/}"

        # Unquoted $abs_allow: bash performs glob expansion on the right side
        # of ==, so patterns like "target/**" or "*.log" work as expected.
        # shellcheck disable=SC2254
        [[ "$path" == $abs_allow || "$path" == "$abs_allow/"* ]] && return 0
    done

    return 1
}

# ── Project blacklist (dynamic) ────────────────────────────────────────────
# Combines three sources:
#   a) gitignored untracked files/dirs  (git ls-files --ignored)
#   b) git-crypt encrypted files        (git crypt status)
#   c) GLOBAL_PROJECT_BLACKLIST patterns (matched against tracked files)
#
# Prints absolute paths, one per line.
build_project_blacklist() {
    local project_dir="$1"

    git -C "$project_dir" rev-parse --git-dir >/dev/null 2>&1 || return 0

    local git_root
    git_root="$(git -C "$project_dir" rev-parse --show-toplevel)"

    # a) gitignored files/directories — run from git_root so relative paths
    #    are always rooted there, even when project_dir is a subdirectory.
    while IFS= read -r rel; do
        [[ -n "$rel" ]] || continue
        echo "$git_root/${rel%/}"   # strip trailing / git adds for dirs
    done < <(
        git -C "$git_root" \
            ls-files --ignored --exclude-standard -o --directory \
            2>/dev/null
    )

    # b) git-crypt encrypted files
    if command -v git-crypt >/dev/null 2>&1; then
        while IFS= read -r rel; do
            [[ -n "$rel" ]] || continue
            echo "$git_root/$rel"
        done < <(
            git -C "$git_root" crypt status 2>/dev/null \
                | awk '/^ *encrypted: / { print $2 }'
        )
    fi

    # c) Global project-level patterns — blocked even if tracked
    local pattern
    for pattern in "${GLOBAL_PROJECT_BLACKLIST[@]}"; do
        while IFS= read -r rel; do
            [[ -n "$rel" ]] || continue
            echo "$git_root/$rel"
        done < <(
            git -C "$git_root" ls-files -- "$pattern" 2>/dev/null
        )
    done
}

# ── Docker socket ──────────────────────────────────────────────────────────
# The Docker socket is intentionally left unrestricted.
#
# Threat model: accidental exfiltration by trusted tools (Claude Code, Codex),
# not a malicious agent. A docker-socket-proxy would add complexity without
# meaningful protection against distraction-driven leaks. An agent that
# deliberately mounts sensitive paths via Docker is already outside the
# threat model this sandbox addresses.

# ── Linux strategy: firejail ───────────────────────────────────────────────

run_firejail() {
    local project_dir="$1"; shift
    local -a cmd=("$@")

    require_cmd firejail

    local git_root=""
    git -C "$project_dir" rev-parse --git-dir >/dev/null 2>&1 \
        && git_root="$(git -C "$project_dir" rev-parse --show-toplevel)"

    # ── Build firejail profile file ──────────────────────────────────────
    # Writing to a profile file avoids ARG_MAX and firejail's own limit on
    # the number of --blacklist= command-line arguments (hit on projects with
    # many gitignored files such as PHP vendor/ trees).
    # --profile=file also suppresses the default profile, like --noprofile.
    local tmp_profile
    tmp_profile="$(mktemp /tmp/ai-sandbox-XXXXXX.profile)"
    # shellcheck disable=SC2064
    trap "rm -f '$tmp_profile'" EXIT

    {
        # Hardware restrictions
        echo "no3d"
        echo "nodvd"
        echo "nosound"
        echo "noautopulse"

        # Global layer (never filtered by ALLOW_PATHS)
        local path
        for path in "${GLOBAL_BLACKLIST[@]}"; do
            echo "blacklist $path"
        done

        # Project dynamic layer (gitignored + git-crypt), filtered by
        # ALLOW_PATHS, then sorted and prefix-deduplicated.
        # Sorting + prefix-dedup collapses children of already-blocked
        # parent dirs (firejail blacklists recursively), reducing the total
        # number of profile entries on projects with many scattered files.
        local allowed_count=0 blocked_count=0
        local -a pending=()
        while IFS= read -r path; do
            [[ -n "$path" ]] || continue
            if [[ -n "$git_root" ]] && is_path_allowed "$path" "$git_root" "$project_dir"; then
                (( allowed_count++ )) || true
            else
                pending+=("$path")
                (( blocked_count++ )) || true
            fi
        done < <(build_project_blacklist "$project_dir")

        # Project explicit extra blocks
        local rel
        for rel in "${AI_SANDBOX_BLOCK_PATHS[@]+"${AI_SANDBOX_BLOCK_PATHS[@]}"}"; do
            [[ "$rel" == /* ]] && path="$rel" || path="$git_root/$rel"
            pending+=("$path")
        done

        # Sort and emit, skipping paths already covered by a parent entry.
        local prev=""
        while IFS= read -r path; do
            if [[ -z "$prev" || "$path" != "$prev/"* ]]; then
                echo "blacklist $path"
                prev="$path"
            fi
        done < <(printf '%s\n' "${pending[@]+"${pending[@]}"}" | sort)

    } > "$tmp_profile"

    log "Blacklist: ${#GLOBAL_BLACKLIST[@]} global" \
        "+ ${#GLOBAL_PROJECT_BLACKLIST[@]} pattern(s)" \
        "+ ${blocked_count} project" \
        "(${allowed_count} skipped: ${#GLOBAL_TOOL_ALLOWLIST[@]} tool dirs + project config)"

    log "Launching: ${cmd[*]}"

    # The full shell environment is inherited unchanged — the agent must
    # be able to impersonate the user (SSH, AWS CLI, direnv vars, etc.).
    firejail \
        --profile="$tmp_profile" \
        -- \
        "${cmd[@]}"
}

# ── macOS strategy: docker run ─────────────────────────────────────────────
# TODO: requires a Docker image with the AI tool pre-installed.
#       Build workflow TBD. For now this is a documented stub.
#
# The image must have the AI tool binary. Mount only the project dir.
# Sensitive $HOME paths are never mounted → exfiltration requires the agent
# to exfiltrate through the network, not the filesystem.

run_docker() {
    local project_dir="$1"; shift
    local -a cmd=("$@")

    require_cmd docker

    local image="${AI_SANDBOX_IMAGE:-ai-sandbox}"

    log "Launching in docker image '$image'"

    # Pass the full current environment so the agent can impersonate the user.
    docker run --rm -it \
        -v "$project_dir:$project_dir:rw" \
        -w "$project_dir" \
        --env-file <(env) \
        "$image" \
        "${cmd[@]}"
}

# ── Debug: print the resolved blacklist ───────────────────────────────────

cmd_debug() {
    local project_dir="${1:-.}"
    project_dir="$(realpath "$project_dir")"

    [[ -d "$project_dir" ]] || die "Not a directory: $project_dir"

    load_project_config "$project_dir"

    local git_root=""
    git -C "$project_dir" rev-parse --git-dir >/dev/null 2>&1 \
        && git_root="$(git -C "$project_dir" rev-parse --show-toplevel)"

    echo "=== Global blacklist (static) ==="
    local path
    for path in "${GLOBAL_BLACKLIST[@]}"; do
        echo "  BLOCKED  $path"
    done

    echo ""
    echo "=== Project dynamic blacklist ==="
    if [[ -z "$git_root" ]]; then
        echo "  (not a git repo)"
    else
        while IFS= read -r path; do
            [[ -n "$path" ]] || continue
            if is_path_allowed "$path" "$git_root" "$project_dir"; then
                echo "  ALLOWED  $path"
            else
                echo "  BLOCKED  $path"
            fi
        done < <(build_project_blacklist "$project_dir")
    fi

    echo ""
    echo "=== Explicit extra blocks (AI_SANDBOX_BLOCK_PATHS) ==="
    if [[ "${#AI_SANDBOX_BLOCK_PATHS[@]}" -eq 0 ]]; then
        echo "  (none)"
    else
        local rel
        for rel in "${AI_SANDBOX_BLOCK_PATHS[@]+${AI_SANDBOX_BLOCK_PATHS[@]}}"; do
            [[ "$rel" == /* ]] && path="$rel" || path="${git_root:-$project_dir}/$rel"
            echo "  BLOCKED  $path"
        done
    fi
}

# ── Init: generate .ai-sandbox template ───────────────────────────────────

cmd_init() {
    local project_dir="${1:-.}"
    project_dir="$(realpath "$project_dir")"

    [[ -d "$project_dir" ]] || die "Not a directory: $project_dir"

    local git_root
    git_root="$(git -C "$project_dir" rev-parse --show-toplevel 2>/dev/null)" \
        || die "Not inside a git repository: $project_dir"

    local config="$git_root/.ai-sandbox"

    if [[ -f "$config" ]]; then
        die ".ai-sandbox already exists: $config"
    fi

    cat > "$config" <<'EOF'
# .ai-sandbox — project-level sandbox configuration
# Generated by: ai-sandbox init
#
# This file is sourced as bash. Arrays support glob patterns.
# Paths are relative to the project git root (or absolute).
# See: https://github.com/ftassi/dotfiles

# ── Paths to ALLOW even if gitignored or git-crypt encrypted ──────────────
# Build artifacts, generated files, vendored deps — things the agent needs
# to read/execute but that aren't secrets.
#
#AI_SANDBOX_ALLOW_PATHS=(
#    target/           # Rust build artifacts
#    dist/             # JS/TS build output
#    .next/            # Next.js build cache
#    node_modules/     # npm packages
#    vendor/           # PHP/Go vendored deps
#    "**/*.log"        # log files anywhere in the tree
#    ".cache/"         # generic cache dirs
#)

# ── Paths to BLOCK in addition to the global + gitignored blacklist ────────
# Use this for tracked files that contain secrets (that shouldn't be there,
# but are — e.g. legacy config committed in plain text).
#
#AI_SANDBOX_BLOCK_PATHS=(
#    config/database.yml
#    infrastructure/terraform.tfvars
#    "**/*.pem"
#)

EOF

    log "Created: $config"
    echo "$config"
}

# ── Main ───────────────────────────────────────────────────────────────────

usage() {
    cat >&2 <<EOF
Usage:
  $(basename "$0") <project-dir> <command> [args...]
  $(basename "$0") init  [project-dir]
  $(basename "$0") debug [project-dir]

Commands:
  init   Generate a commented .ai-sandbox config in the project git root.
         Defaults to current directory if project-dir is omitted.
  debug  Print the resolved blacklist for a project directory without
         launching a sandbox. Useful to verify what would be blocked.
         Defaults to current directory if project-dir is omitted.

Sandboxes an AI tool with filesystem blacklisting. The full shell
environment is inherited so the agent can impersonate the user.
Project-level overrides are read from .ai-sandbox in the git root.

Examples:
  $(basename "$0") ~/myproject claude
  $(basename "$0") . codex --model gpt-4o
  $(basename "$0") init ~/myproject
  $(basename "$0") debug ~/myproject

Environment:
  AI_SANDBOX_IMAGE   Docker image to use on macOS (default: ai-sandbox)
EOF
    exit 1
}

main() {
    [[ $# -ge 1 ]] || usage

    # Subcommands: init, debug
    if [[ "$1" == "init" ]]; then
        cmd_init "${2:-}"
        return
    fi

    if [[ "$1" == "debug" ]]; then
        cmd_debug "${2:-}"
        return
    fi

    [[ $# -ge 2 ]] || usage

    local project_dir
    project_dir="$(realpath "$1")"
    shift

    local -a cmd=("$@")

    [[ -d "$project_dir" ]] || die "Not a directory: $project_dir"

    load_project_config "$project_dir"

    local os
    os="$(detect_os)"

    case "$os" in
        linux) run_firejail "$project_dir" "${cmd[@]}" ;;
        macos) run_docker   "$project_dir" "${cmd[@]}" ;;
    esac
}

main "$@"

#!/usr/bin/env bash
# ai-sandbox — Secure wrapper for AI coding tools
#
# Threat model: accidental exfiltration — agent reads a sensitive file
# and includes it in context without the user noticing.
#
# Protection layers:
#   1. Filesystem blacklist (project dynamic)
#   2. Environment clearenv + explicit whitelist
#   3. Docker socket mediation via docker-socket-proxy (TODO)
#
# Strategies:
#   Linux  → firejail (profile file with blacklist directives)
#   macOS  → docker run with selective volume mounts (stub, see TODO)
#
# Usage:
#   ai-sandbox <project-dir> <command> [args...]
#   ai-sandbox init [project-dir]      # generate .ai-sandbox config
#
# Examples:
#   ai-sandbox ~/myproject claude
#   ai-sandbox init ~/myproject
#   ai-sandbox . codex --model gpt-4o
#
# Environment overrides:
#   AI_SANDBOX_IMAGE    Docker image for macOS strategy (default: ai-sandbox)

set -euo pipefail

# ── Global project-level blacklist (secret file patterns) ──────────────────
# Secret-file name patterns blocked in every project.
# Matched against both tracked files (accidentally committed) and
# untracked gitignored files (properly gitignored secrets).
#
# Intentionally NOT "all gitignored files": vendor/, node_modules/, logs,
# and other build artifacts remain accessible to the agent.
#
# Both root-level and **/ variants are listed for git ls-files pathspec
# compatibility. Basenames are derived dynamically for the gitignored
# post-filter, so adding a pattern here is sufficient.
# Can be overridden by AI_SANDBOX_ALLOW_PATHS in .ai-sandbox.
GLOBAL_PROJECT_BLACKLIST=(
    # ── Environment / direnv ────────────────────────────────────────────────
    ".env"                  "**/.env"
    ".env.local"            "**/.env.local"
    ".env.production"       "**/.env.production"
    ".env.staging"          "**/.env.staging"
    ".env.*.local"          "**/.env.*.local"
    ".envrc"                "**/.envrc"

    # ── Private keys and certificates ───────────────────────────────────────
    "*.pem"                 "**/*.pem"
    "*.key"                 "**/*.key"
    "*.p12"                 "**/*.p12"
    "*.pfx"                 "**/*.pfx"
    "*.der"                 "**/*.der"
    "*.jks"                 "**/*.jks"         # Java keystores

    # ── Cloud / infrastructure ───────────────────────────────────────────────
    "credentials.json"      "**/credentials.json"
    "service-account.json"  "**/service-account.json"
    "terraform.tfvars"      "**/terraform.tfvars"
    "*.tfvars"              "**/*.tfvars"

    # ── Generic secret file names ────────────────────────────────────────────
    "secrets.yml"           "**/secrets.yml"
    "secrets.json"          "**/secrets.json"
    ".secrets"              "**/.secrets"
    "*.vault"               "**/*.vault"       # Ansible Vault encrypted files

    # ── Framework-specific ───────────────────────────────────────────────────
    "config/master.key"                        # Rails 5.2+ credentials key
    "config/secrets.yml"                       # Rails 4.x secrets
    "parameters.yml"        "**/parameters.yml" # Symfony 2/3 local parameters
    "parameters.php"        "**/parameters.php" # Symfony 2/3 alt format
    "auth.json"             "**/auth.json"     # Composer / npm token store
    ".netrc"                "**/.netrc"        # curl / git credential helper
    ".htpasswd"             "**/.htpasswd"     # HTTP basic auth
    "wp-config.php"         "**/wp-config.php" # WordPress DB credentials
)

# ── Global tool directory allowlist ────────────────────────────────────────
# AI tool config directories that must always be accessible to the agent,
# even if encrypted with git-crypt. Override the dynamic blacklist.
# Paths are relative to the project git root.
GLOBAL_TOOL_ALLOWLIST=(
    ".claude"    # Claude Code — project settings, AGENT.md
    ".codex"     # OpenAI Codex CLI — project config
    ".aider"     # Aider — conversation history, config
    ".continue"  # Continue.dev — context, config
)

# ── Project config defaults ────────────────────────────────────────────────
# Overridden by .ai-sandbox in the project git root.
AI_SANDBOX_ALLOW_PATHS=()
AI_SANDBOX_BLOCK_PATHS=()

# ── Helpers ────────────────────────────────────────────────────────────────

die()  { echo "ai-sandbox: ERROR: $*" >&2; exit 1; }
log()  { echo "ai-sandbox: $*" >&2; }

detect_os() {
    case "$(uname -s)" in
        Linux)  echo linux ;;
        Darwin) echo macos ;;
        *)      die "Unsupported OS: $(uname -s)" ;;
    esac
}

require_cmd() {
    command -v "$1" >/dev/null 2>&1 \
        || die "Required command not found: '$1'. Install it and retry."
}

# ── Project config (.ai-sandbox) ──────────────────────────────────────────

# Loads .ai-sandbox from the git root of project_dir, if present.
# Sets AI_SANDBOX_{ALLOW,BLOCK}_PATHS globals.
load_project_config() {
    local project_dir="$1"

    git -C "$project_dir" rev-parse --git-dir >/dev/null 2>&1 || return 0

    local git_root config
    git_root="$(git -C "$project_dir" rev-parse --show-toplevel)"
    config="$git_root/.ai-sandbox"

    [[ -f "$config" ]] || return 0

    log "Loading project config: $config"
    # shellcheck source=/dev/null
    source "$config"
}

# Returns 0 if the absolute path is allowed by either:
#   1. GLOBAL_TOOL_ALLOWLIST — hardcoded AI tool dirs (always allowed)
#   2. AI_SANDBOX_ALLOW_PATHS — project-level config (.ai-sandbox)
# Patterns are relative to git_root; glob syntax is supported.
# A directory pattern (e.g. target/) also allows everything beneath it.
#
# project_dir (optional, defaults to git_root): also checked as base for
# GLOBAL_TOOL_ALLOWLIST, so tool dirs in a subdirectory project are rescued.
is_path_allowed() {
    local path="$1" git_root="$2" project_dir="${3:-$2}"
    local allow abs_allow base

    # Global tool allowlist — checked against both git_root and project_dir
    # so that tool dirs in a monorepo subdirectory are correctly rescued.
    for allow in "${GLOBAL_TOOL_ALLOWLIST[@]}"; do
        for base in "$git_root" "$project_dir"; do
            [[ "$allow" == /* ]] \
                && abs_allow="${allow%/}" \
                || abs_allow="$base/${allow%/}"
            [[ "$path" == $abs_allow || "$path" == "$abs_allow/"* ]] && return 0
        done
    done

    # Project-level allowlist from .ai-sandbox
    for allow in "${AI_SANDBOX_ALLOW_PATHS[@]+${AI_SANDBOX_ALLOW_PATHS[@]}}"; do
        [[ "$allow" == /* ]] \
            && abs_allow="${allow%/}" \
            || abs_allow="$git_root/${allow%/}"

        # Unquoted $abs_allow: bash performs glob expansion on the right side
        # of ==, so patterns like "target/**" or "*.log" work as expected.
        # shellcheck disable=SC2254
        [[ "$path" == $abs_allow || "$path" == "$abs_allow/"* ]] && return 0
    done

    return 1
}

# ── Project blacklist (dynamic) ────────────────────────────────────────────
# Combines two sources:
#   a) git-crypt encrypted files  (git crypt status)
#   b) GLOBAL_PROJECT_BLACKLIST   (secret file-name patterns, see above)
#
# Gitignored files are NOT blocked wholesale. Only files whose names match
# known secret-file patterns are blocked — whether tracked (accidentally
# committed) or untracked gitignored (properly gitignored secrets).
# Build artifacts, dependencies, and logs remain accessible.
#
# Prints absolute paths, one per line.
build_project_blacklist() {
    local project_dir="$1"

    git -C "$project_dir" rev-parse --git-dir >/dev/null 2>&1 || return 0

    local git_root
    git_root="$(git -C "$project_dir" rev-parse --show-toplevel)"

    # a) git-crypt encrypted files.
    #    git crypt status is O(tracked files) and very slow on large repos.
    #    Guard with .git-crypt/ presence: git crypt init creates this directory,
    #    so its absence means the repo does not use git-crypt.
    if command -v git-crypt >/dev/null 2>&1 && [[ -d "$git_root/.git-crypt" ]]; then
        while IFS= read -r rel; do
            [[ -n "$rel" ]] || continue
            echo "$git_root/$rel"
        done < <(
            git -C "$git_root" crypt status 2>/dev/null \
                | awk '/^ *encrypted: / { print $2 }'
        )
    fi

    # b) Tracked files matching secret patterns — fast index lookup.
    while IFS= read -r rel; do
        [[ -n "$rel" ]] || continue
        echo "$git_root/$rel"
    done < <(
        git -C "$git_root" ls-files \
            -- "${GLOBAL_PROJECT_BLACKLIST[@]}" 2>/dev/null
    )

    # c) Untracked gitignored secret files.
    #    --directory prevents git from recursing into entirely-gitignored dirs
    #    (vendor/, node_modules/ → single entry, not traversed).
    #    NOTE: git ls-files --ignored -o does NOT honour pathspec as a filter
    #    for individual files — it returns all gitignored content regardless.
    #    We post-filter by basename using GLOBAL_PROJECT_BLACKLIST patterns
    #    so the two lists stay in sync automatically.
    local -a _bp=()
    local _pat
    for _pat in "${GLOBAL_PROJECT_BLACKLIST[@]}"; do
        _bp+=("${_pat##*/}")
    done

    while IFS= read -r rel; do
        [[ -n "$rel" ]] || continue
        local base="${rel##*/}" _matched=false _p
        for _p in "${_bp[@]}"; do
            # shellcheck disable=SC2254
            [[ "$base" == $_p ]] && { _matched=true; break; }
        done
        [[ "$_matched" == true ]] || continue
        echo "$git_root/${rel%/}"
    done < <(
        git -C "$git_root" ls-files --ignored --exclude-standard -o --directory \
            2>/dev/null
    )
}

# ── Docker socket ──────────────────────────────────────────────────────────
# The Docker socket is intentionally left unrestricted.
#
# Threat model: accidental exfiltration by trusted tools (Claude Code, Codex),
# not a malicious agent. A docker-socket-proxy would add complexity without
# meaningful protection against distraction-driven leaks. An agent that
# deliberately mounts sensitive paths via Docker is already outside the
# threat model this sandbox addresses.

# ── Linux strategy: firejail ───────────────────────────────────────────────

run_firejail() {
    local project_dir="$1"; shift
    local -a cmd=("$@")

    require_cmd firejail

    local git_root=""
    git -C "$project_dir" rev-parse --git-dir >/dev/null 2>&1 \
        && git_root="$(git -C "$project_dir" rev-parse --show-toplevel)"

    # ── Build firejail profile file ──────────────────────────────────────
    # Writing to a profile file avoids ARG_MAX and firejail's own limit on
    # the number of --blacklist= command-line arguments (hit on projects with
    # many gitignored files such as PHP vendor/ trees).
    # --profile=file also suppresses the default profile, like --noprofile.
    local tmp_profile
    tmp_profile="$(mktemp /tmp/ai-sandbox-XXXXXX.profile)"
    # shellcheck disable=SC2064
    trap "rm -f '$tmp_profile'" EXIT

    {
        # Hardware restrictions
        echo "no3d"
        echo "nodvd"
        echo "nosound"
        echo "noautopulse"

        # Project dynamic layer (git-crypt + secret-pattern matches), filtered by
        # ALLOW_PATHS, then sorted and prefix-deduplicated.
        # Sorting + prefix-dedup collapses children of already-blocked
        # parent dirs (firejail blacklists recursively), reducing the total
        # number of profile entries on projects with many scattered files.
        local path allowed_count=0 blocked_count=0
        local -a pending=()
        while IFS= read -r path; do
            [[ -n "$path" ]] || continue
            if [[ -n "$git_root" ]] && is_path_allowed "$path" "$git_root" "$project_dir"; then
                (( allowed_count++ )) || true
            else
                pending+=("$path")
                (( blocked_count++ )) || true
            fi
        done < <(build_project_blacklist "$project_dir")

        # Project explicit extra blocks
        local rel
        for rel in "${AI_SANDBOX_BLOCK_PATHS[@]+"${AI_SANDBOX_BLOCK_PATHS[@]}"}"; do
            [[ "$rel" == /* ]] && path="$rel" || path="$git_root/$rel"
            pending+=("$path")
        done

        # Sort and emit, skipping paths already covered by a parent entry.
        local prev=""
        while IFS= read -r path; do
            if [[ -z "$prev" || "$path" != "$prev/"* ]]; then
                echo "blacklist $path"
                prev="$path"
            fi
        done < <(printf '%s\n' "${pending[@]+"${pending[@]}"}" | sort)

    } > "$tmp_profile"

    log "Blacklist: ${#GLOBAL_PROJECT_BLACKLIST[@]} pattern(s)" \
        "+ ${blocked_count} project" \
        "(${allowed_count} skipped: ${#GLOBAL_TOOL_ALLOWLIST[@]} tool dirs + project config)"

    log "Launching: ${cmd[*]}"

    # The full shell environment is inherited unchanged — the agent must
    # be able to impersonate the user (SSH, AWS CLI, direnv vars, etc.).
    firejail \
        --profile="$tmp_profile" \
        -- \
        "${cmd[@]}"
}

# ── macOS strategy: docker run ─────────────────────────────────────────────
# TODO: requires a Docker image with the AI tool pre-installed.
#       Build workflow TBD. For now this is a documented stub.
#
# The image must have the AI tool binary. Mount only the project dir.
# Sensitive $HOME paths are never mounted → exfiltration requires the agent
# to exfiltrate through the network, not the filesystem.

run_docker() {
    local project_dir="$1"; shift
    local -a cmd=("$@")

    require_cmd docker

    local image="${AI_SANDBOX_IMAGE:-ai-sandbox}"

    log "Launching in docker image '$image'"

    # Pass the full current environment so the agent can impersonate the user.
    docker run --rm -it \
        -v "$project_dir:$project_dir:rw" \
        -w "$project_dir" \
        --env-file <(env) \
        "$image" \
        "${cmd[@]}"
}

# ── Debug: print the resolved blacklist ───────────────────────────────────

cmd_debug() {
    local project_dir="${1:-.}"
    project_dir="$(realpath "$project_dir")"

    [[ -d "$project_dir" ]] || die "Not a directory: $project_dir"

    load_project_config "$project_dir"

    local git_root="" path
    git -C "$project_dir" rev-parse --git-dir >/dev/null 2>&1 \
        && git_root="$(git -C "$project_dir" rev-parse --show-toplevel)"

    echo "=== Project dynamic blacklist ==="
    if [[ -z "$git_root" ]]; then
        echo "  (not a git repo)"
    else
        while IFS= read -r path; do
            [[ -n "$path" ]] || continue
            if is_path_allowed "$path" "$git_root" "$project_dir"; then
                echo "  ALLOWED  $path"
            else
                echo "  BLOCKED  $path"
            fi
        done < <(build_project_blacklist "$project_dir")
    fi

    echo ""
    echo "=== Explicit extra blocks (AI_SANDBOX_BLOCK_PATHS) ==="
    if [[ "${#AI_SANDBOX_BLOCK_PATHS[@]}" -eq 0 ]]; then
        echo "  (none)"
    else
        local rel
        for rel in "${AI_SANDBOX_BLOCK_PATHS[@]+${AI_SANDBOX_BLOCK_PATHS[@]}}"; do
            [[ "$rel" == /* ]] && path="$rel" || path="${git_root:-$project_dir}/$rel"
            echo "  BLOCKED  $path"
        done
    fi
}

# ── Init: generate .ai-sandbox template ───────────────────────────────────

cmd_init() {
    local project_dir="${1:-.}"
    project_dir="$(realpath "$project_dir")"

    [[ -d "$project_dir" ]] || die "Not a directory: $project_dir"

    local git_root
    git_root="$(git -C "$project_dir" rev-parse --show-toplevel 2>/dev/null)" \
        || die "Not inside a git repository: $project_dir"

    local config="$git_root/.ai-sandbox"

    if [[ -f "$config" ]]; then
        die ".ai-sandbox already exists: $config"
    fi

    cat > "$config" <<'EOF'
# .ai-sandbox — project-level sandbox configuration
# Generated by: ai-sandbox init
#
# This file is sourced as bash. Arrays support glob patterns.
# Paths are relative to the project git root (or absolute).
# See: https://github.com/ftassi/dotfiles

# ── Paths to ALLOW even if blocked by secret-file patterns or git-crypt ───
# Use when a file matches a blocked pattern but is not a secret in this
# project, or when a git-crypt encrypted file must be readable by the agent.
#
#AI_SANDBOX_ALLOW_PATHS=(
#    "**/.env.test"          # test env vars, not secret in this project
#    config/credentials.json # non-secret credentials (e.g. OAuth app scopes)
#)

# ── Paths to BLOCK in addition to the dynamic blacklist ───────────────────
# Use this for tracked files that contain secrets (that shouldn't be there,
# but are — e.g. legacy config committed in plain text).
#
#AI_SANDBOX_BLOCK_PATHS=(
#    config/database.yml
#    infrastructure/terraform.tfvars
#    "**/*.pem"
#)

EOF

    log "Created: $config"
    echo "$config"
}

# ── Main ───────────────────────────────────────────────────────────────────

usage() {
    cat >&2 <<EOF
Usage:
  $(basename "$0") <project-dir> <command> [args...]
  $(basename "$0") init  [project-dir]
  $(basename "$0") debug [project-dir]

Commands:
  init   Generate a commented .ai-sandbox config in the project git root.
         Defaults to current directory if project-dir is omitted.
  debug  Print the resolved blacklist for a project directory without
         launching a sandbox. Useful to verify what would be blocked.
         Defaults to current directory if project-dir is omitted.

Sandboxes an AI tool with filesystem blacklisting. The full shell
environment is inherited so the agent can impersonate the user.
Project-level overrides are read from .ai-sandbox in the git root.

Examples:
  $(basename "$0") ~/myproject claude
  $(basename "$0") . codex --model gpt-4o
  $(basename "$0") init ~/myproject
  $(basename "$0") debug ~/myproject

Environment:
  AI_SANDBOX_IMAGE   Docker image to use on macOS (default: ai-sandbox)
EOF
    exit 1
}

main() {
    [[ $# -ge 1 ]] || usage

    # Subcommands: init, debug
    if [[ "$1" == "init" ]]; then
        cmd_init "${2:-}"
        return
    fi

    if [[ "$1" == "debug" ]]; then
        cmd_debug "${2:-}"
        return
    fi

    [[ $# -ge 2 ]] || usage

    local project_dir
    project_dir="$(realpath "$1")"
    shift

    local -a cmd=("$@")

    [[ -d "$project_dir" ]] || die "Not a directory: $project_dir"

    load_project_config "$project_dir"

    local os
    os="$(detect_os)"

    case "$os" in
        linux) run_firejail "$project_dir" "${cmd[@]}" ;;
        macos) run_docker   "$project_dir" "${cmd[@]}" ;;
    esac
}

main "$@"
